

#this is the main script for:
# 1. combining nostril ROI position and calculating temperature values.
# 2. Detecting respiration peaks and phases
# 3. Marking respiration cycles according to the presence of vocalizations
# 4. Measuring respiration phase duration, amplitude and slope
# 5. Summarizing data for analysis

### there are a few steps for renaming files and creating conversion table
### for matching data objects from different sources. The relevant lines of code
### will need to be adapted to your own formats. As is, the script runs on the 
### specific file naming convention used for this project. Sample files are
### provided and can be explored for data structure and build


library(Thermimage)
library(ggplot2)
library(stringr)
library(pracma)
library(KernSmooth)


#setting  cutoff values
#length of sequential frame detection
frame_seq <- 100
# temperature spike height
temp_cutoff <- 1.5 #avoiding short term temperature spikes

######reading in nostril position detection data and combining it 
######with extracted color values######

#reading in data from loopy and imageJ
imageJ_output_dir <- "/cloud/project/imageJ_output"
#input files with ROI color intensity measurements from ImageJ. Having Frame number, Min, max and Median measurements
loopy_output_dir <- "/cloud/project/loopy_output"
#input files with ROI detection position, generated by Loopy. Having Frame number, XY coordinates, ROI laterality

#list all input files
imageJ_files <- list.files (imageJ_output_dir, pattern = ".csv")
loopy_files <- list.files (loopy_output_dir, pattern = ".csv")

#trim file names for matching between ImageJ and Loopy files
loopy_files_trimmed <-
  substring(loopy_files, 47, nchar(loopy_files) - 30)
loopy_files <- cbind(loopy_files, loopy_files_trimmed)
loopy_files[, 2] <-
  paste(loopy_files[, 2], "_out.csv", sep = "")
loopy_files <- data.frame(loopy_files, stringsAsFactors = F)
      ##adapt file renaming to the relevant file naming scheme if needed

#make a matching conversion table for video file names
proc_file_list <-
  data.frame(intersect(loopy_files[, 2] , imageJ_files), stringsAsFactors = F)
proc_file_list <-
  merge(
    loopy_files,
    proc_file_list,
    by.x = "loopy_files_trimmed",
    by.y = "intersect.loopy_files...2...imageJ_files.",
    all.x = F
  )
proc_file_list <-
  proc_file_list[!duplicated(proc_file_list$loopy_files_trimmed),]
    #adapt file renaming and conversion table to the relevant file naming scheme


#make empty data frame for collecting all input
temp_mes <- data.frame()

#loop through all individual files
for (i in 1:nrow(proc_file_list)) {
  #read one loopy output file
  loopy <-
    read.csv(paste(loopy_output_dir, "/", proc_file_list[i, 2], sep = ""))
  
  #correct slice count by adding  1 frame to each
  loopy$imageJframe <- loopy$frame_number + 1
  
  #sorting rows by nostrilR and nostrilL
  loopy <-  loopy[order(loopy$name, decreasing = T),]
  
  #getting file name
  video_file_name <- proc_file_list[i, 1]
  
  #read imageJ output file
  imageJ <-
    read.csv(paste(imageJ_output_dir, "/" ,  video_file_name, sep = ""))
  
  #combine frame numbers with the correct nostril side
  imageJ <-
    cbind(imageJ, loopy$name, loopy$imageJframe, video_file_name)
  
  #collect all into one data frame
  temp_mes <-
    rbind(temp_mes, imageJ) 
  
}
print("at this point we have the pixel intensity values synced with frame number and identified by ROI laterality")

Sys.sleep(5)

#####convert color intensity to temperature ######

temp_mes$Median <- as.numeric(temp_mes$Median)

# Obtain the calibration constants from the csq files
# we used Exiftool (a command line utility to do this), but
# this functionality is included  in Thermimage

PR1 <- 21546.2
PB <- 1507
PF <- 1
PO <- (-6331)
PR2 <- 0.01622949

# Set the object parameters required for the raw -> temperature
# conversion
# Emissivity, Object Distance, Reflected Temperature, Atmospheric Temperature,
# IR Window Temperature, IRT
E <- 0.95
OD <- 1
RTemp <- 10
ATemp <- 10
IRWTemp <- 10
IRT <- 1
RH <- 30

# we only report on temperatures above 0C and below 40C (relevant for a mammalian system),
# so  the raw values are truncated to a much more reasonable range:
rawvalues <- 10000:20000
tempvalues <-
  raw2temp(
    rawvalues,
    E,
    OD,
    RTemp,
    ATemp,
    IRWTemp = RTemp,
    IRT = 1,
    RH,
    PR1,
    PB,
    PF,
    PO,
    PR2
  )

# add these temp values to a data.frame
d <- data.frame(rawvalues, tempvalues)

lm1 <- lm(tempvalues ~ stats::poly(rawvalues, 4), data = d)

# or the easier approach is to use the predict function
temp_mes$Median <-
  predict(lm1, newdata = data.frame(rawvalues = temp_mes$Median)) #at this point the pixel intensity for the ROI  is transformed to temperature

print("Next is the quality control of the data")
Sys.sleep(5)


######quality control of data####

#filtering out short tracks

#make empty data frame to collect long tracks
long_tracks_all <- data.frame()

#loop through all data files
for (j in 1:nrow(proc_file_list))
{
  #selecting one video file output
  one <-
    subset(temp_mes, temp_mes$video_file_name == proc_file_list[j, 1])
  
  x <- 1
  
  #adding column for marking frame sequences
  one$seg <- NA
  
  #marking frame sequences without gaps above 5 frames
  for (i in 1:(nrow(one) - 1))
  {
    if (one[i + 1, "Slice"] - one[i, "Slice"] < 6 &
        one[i + 1, "Slice"] - one[i, "Slice"] > 0)
    {
      one[i, "seg"] <- x
    }
    else
    {
      one[i, "seg"] <- x
      x <- x + 1
    }
  }
  
  
  #finding sequence lengts
  seg_lenghts <- data.frame(table(one$seg))
  
  
  #finding tracks longer than a set number of frames
  track_num <- which(seg_lenghts[, 2] > frame_seq)
  
  #if no long frame sequence in the file, go to  next
  if (length(track_num) < 1)
  {
    next
  }
  
  ####filtering the color values and filtering out temperature jumps
  
  #choosing long tracks only
  
  long_tracks <-
    one[one$seg %in% which(seg_lenghts[, 2] > frame_seq),]
  
  ##converting frames to time in seconds (deviding by 30). 
  ##This should be changed according to the fps rate of the video material!!!!!!
  long_tracks$time <- long_tracks$Slice / 30
  
  
  #set the temp change cutoff.
  z <- temp_cutoff
  
  #duplicating temp value column to filter later
  long_tracks$filt_median <- long_tracks$Median
  
  #getting rid of short intensity spikes above cutoff
  for (i in track_num)
  {
    seg_select <-  subset(long_tracks, long_tracks$seg == i)
    seg_select$dist <- NA
    
    #checking first and last frame in the sequence
    seg_select[1 , "dist"] <-
      abs(seg_select[2, "Median"] - seg_select[1, "Median"])
    seg_select[nrow(seg_select) , "dist"] <-
      abs(seg_select[nrow(seg_select) - 1, "Median"] - seg_select[nrow(seg_select), "Median"])
    
    #checking the rest of the values
    for (y in 1:(nrow(seg_select) - 1))
    {
      seg_select[y + 1 , "dist"] <-
        abs(seg_select[y + 1, "Median"] - seg_select[y, "Median"])
      seg_select[which(seg_select$dist > z), "filt_median"] <- NA
      
    }
    
    #collecting all filtered long tracks back together into one data frame
    long_tracks_all <- rbind(long_tracks_all, seg_select)
  }
}

#add video file number to each row
#the renaming and file conversion should be adapted to the relevant naming convention
long_tracks_all$video_file_num <-
  substr(long_tracks_all$video_file_name, 16, 18)

#make unique segment ID
long_tracks_all$seqID <-
  paste(long_tracks_all$video_file_name, long_tracks_all$seg) # at this point we have only continuous ROI tracks without gaps


#finding segments with both nostrils tracked. This is done to control for filming angle

filt_file_list <- unique(long_tracks_all$video_file_name)

#make empty df for filling with filtered segments <-
cleaned_files_list <- matrix(NA, ncol = 3, nrow = 0)
for (i in filt_file_list) {
  select_file_nostrilL <-
    subset(
      long_tracks_all,
      long_tracks_all$video_file_name == i &
        long_tracks_all$`loopy$name` == "NostrilL"
    )
  select_file_nostrilR <-
    subset(
      long_tracks_all,
      long_tracks_all$video_file_name == i &
        long_tracks_all$`loopy$name` == "NostrilR"
    )
  # if only one nostril tracked skip to next file
  l_dur <- nrow(select_file_nostrilL)
  r_dur <- nrow(select_file_nostrilR)
  
  if (l_dur == 0 | r_dur == 0) {
    next
  }
  
  #merge both nostrils into one data frame
  both_nostrils <-
    merge(select_file_nostrilR,
          select_file_nostrilL[, 3:10],
          by.x = "Slice",
          by.y = "Slice")
  
  #get long frame sequences
  frame_seq <- unique(both_nostrils$seg.x)
  
  for (j in frame_seq) {
    #plot temp curves for visual inspection
    seq_plot <-
      ggplot(data = both_nostrils[which(both_nostrils$seg.x == j) ,], aes(x = Slice)) +
      geom_line (aes(y = Median.x), color = "red") + geom_line(aes(y = Median.y), color = "blue") +
      ggtitle(
        paste(
          i,
          "\n",
          "Red _Right_nost_seg_",
          j,
          "\n",
          "Blue_Left_nost_seg_",
          both_nostrils[max(which(both_nostrils$seg.x == j)) , "seg.y"]
        )
      )
    print(seq_plot)
    
    #capture file and sequence name
    R_seq <- c(i, j, "NostrilR")
    L_seq <-
      c (i , both_nostrils[max(which(both_nostrils$seg.x == j)) , "seg.y"], "NostrilL")
    cleaned_files_list <- rbind(cleaned_files_list, R_seq, L_seq)
  }
}

print ("at this point visually inspect curves and manually select ones showing potentially clean breathing traces make list of files and sequence numbers for further analysis")

Sys.sleep(5)


#####at this point visually inspect curves and manually select ones showing potentially clean breathing traces ######
#####make list of files and sequence numbers for further analysis #######

#select only relevant frame sequences
row.names(cleaned_files_list) <- NULL

## output a file for interim control
write.csv(cleaned_files_list, "/cloud/project/data_outputs/segments_for_filt.csv")

#this selection is done manually from visual inspection of the plots

###manual sequence selections
#select sequences
cleaned_files_list <-
  data.frame(cleaned_files_list[c(2, 3, 8, 15, 16, 25) ,])
#select start frames
cleaned_files_list$fs <-
  c(0, 3500,  500, 3620, 2970, 4475)
#select end frames
cleaned_files_list$ef <-
  c(450, 3680, 750, 4080, 3450, 4700)

rows <- nrow(cleaned_files_list)

cleaned_files_list$runID <- seq(1, nrow(cleaned_files_list), 1)

#filter all video data according to manual inspection
cleaned_files_list <- stacomirtools::killfactor(cleaned_files_list)
long_tracks_all <- stacomirtools::killfactor(long_tracks_all)


long_tracks_filt_frames <- data.frame(stringsAsFactors = F)

for (i in 1:nrow(cleaned_files_list))
{
  file_selct <-
    subset(long_tracks_all,
           long_tracks_all$video_file_name == cleaned_files_list$X1[i])
  nostril_select <-
    subset(file_selct,
           file_selct$`loopy$name` == cleaned_files_list$X3[i])
  frame_slect <-
    nostril_select[which(
      nostril_select$Slice >= cleaned_files_list$fs[i] &
        nostril_select$Slice <= cleaned_files_list$ef[i]
    ) ,]
  frame_slect$runID = cleaned_files_list[i, "runID"]
  long_tracks_filt_frames <-
    rbind(long_tracks_filt_frames, frame_slect)
  
}

long_tracks_filt_frames$seqID <-
  paste (long_tracks_filt_frames$video_file_name,
         long_tracks_filt_frames$runID)
# at this point we have tracks that demonstrate continuous and cyclic patterns

print ("at this point we have tracks that demonstrate continuous and cyclic patterns")
Sys.sleep(5)


#######sync audio labels with video frames#######

#load audio data file. it should include call times and 
#relevant metadata (date, ID, etc)
call_times <-
  read.csv("/cloud/project/outputs/thermal_audio_raw_timing.csv",
           stringsAsFactors = FALSE)


##cleanup file names and arrange meta data of audio files
## specific steps depend on file naming conventions

call_times$file <-
  substr(call_times$filename, 57, nchar(call_times$filename) - 4)
call_times <-
  cbind(call_times, str_split_fixed(call_times$file, "_", 2))
call_times <-
  cbind(call_times, str_split_fixed(call_times$`2` , "\\\\", 2))

call_times_clean <- call_times[, c(2, 3, 4, 5, 12, 14, 16, 17)]
colnames(call_times_clean)[6] <- "date"
colnames(call_times_clean)[7] <- "group"
colnames(call_times_clean)[8] <- "track"
call_times_clean$track <- gsub('L', "", call_times_clean$track)

##load records log file. This file includes the Audio-Video file matches 
##and sync times between video frames and audio call timing
logfile <-
  read.csv("/cloud/project/outputs/thermal_logfile.csv",
           stringsAsFactors = F)
logfile <- logfile[,-c(11:14)]

#format data column
logfile$Date <- gsub('-', "", logfile$Date)


#merge call times with ID and video data by matching meta data
merged_data <-
  merge(
    call_times_clean,
    logfile,
    by.x = c("date", "group", "track"),
    by.y = c("Date", "Group", "Audio.file"),
    all.x = F
  )

##calculate sync time with video. This depends on the format of the syncs and the desired time format (seconds or frames)
merged_data$frames <- as.numeric(merged_data$frames)
merged_data$frames[is.na(merged_data$frames)] <- 0
merged_data$syncT <- (merged_data$sec * 30)


##convert time from seconds into frames
##the calculation is dependent on the FPS of the vide matherial.
##30 frames per second in our case
merged_data$StartT <-
  merged_data$start.time * 30 + merged_data$syncT + merged_data$frames
merged_data$EndT <-
  merged_data$end.time * 30 + merged_data$syncT + merged_data$frames
merged_data$AV.Sync.time.s. <- NULL
merged_data$Audio.labled <- NULL
##### at this point the audio and video outputs are combined and are on the same time line ###

print ("at this point the audio and video outputs are combined and are on the same time line")
Sys.sleep(5)

#### marking frames with calls #####
#list relevant video files
video_file_list <-
  as.numeric(unique(long_tracks_filt_frames$video_file_num))

#create empty frame to fill with data
AVsummary <- data.frame()

for (x in video_file_list)
{
  #print video file number
  print(x)
  #choose one audio file
  one_video_calls <-
    subset(merged_data, merged_data$Video.file == x)
  #if no matching audio file go to next
  if (is.na(match(x, long_tracks_filt_frames$video_file_num)) == T)
  {
    next
  }
  #choose matching video file
  one_video_colours <-
    subset(long_tracks_filt_frames,
           long_tracks_filt_frames$video_file_num == x)
  
  for (i in 1:nrow(one_video_calls))
  {
    #find matching frames for call times
    frame <-
      which(
        one_video_colours$Slice > one_video_calls$StartT[i] &
          one_video_colours$Slice < one_video_calls$EndT[i]
      )
    #fill call type in corresponding frames
    one_video_colours [frame , "call_type"] <-
      one_video_calls[i , "label"]
  }
  #collect all data in one big file
  AVsummary <- rbind(AVsummary, one_video_colours)
}



#add call indicatoe column and mark all existing focal call as 1

AVsummary$Calls <- 0
AVsummary[which(
  !is.na(AVsummary$call_type) &
    AVsummary$call_type != "nf" &
    AVsummary$call_type != "nf sn"
), "Calls"] <- 1
AVsummary[which(AVsummary$call_type == "nf") , "Calls"] <- 1 / 2
AVsummary[which(AVsummary$call_type == "nf sn") , "Calls"] <- 1 / 2


#now the frames with calls are marked as 1, frames with NonFocal calls marked as 0.5, frames without calls are marked as 0

###plot curves against for controlling the data going into the next stage
###another opportunity to check if the curves look good and make filtering if needed
upd_file_lst <- unique(AVsummary$seqID)

for (i in upd_file_lst)
{
  segment <- subset(AVsummary, AVsummary$seqID == i)
  plot(
    segment$time ,
    segment$Median,
    type = 'l',
    lwd = 1,
    col = 'red' ,
    main = i
  )
  
  
}


### at this point all data is combined together and ready for next steps ###

######digital filter data smoothing######


#library
library(lubridate)
library(readxl)
library(dplyr)
library(robfilter)

#creating empty matrix for end output
summ <- matrix(NA , 0, 28) #this is the data-frame that will collect final data summary
raw_summ <- data.frame()

#making a vector for breathing rate check
Breathrate_tot <- data.frame(stringsAsFactors = F)


for (k in 1:length(upd_file_lst))
{
  d <- subset(AVsummary, AVsummary$seqID == upd_file_lst[k]) #select one segment
  
  #check for segment length. Short segments are ignored
  if (nrow(d) < 120) {
    next
  }
  
  #filling NA with mean values since some of the stages do not accept NAs
  CM <- mean(d[, "filt_median"], na.rm = T) #get mean value of the segment
  for (b in 1:nrow(d))
  {
    d[b , "filt_median"] = ifelse(is.na(d[b, "filt_median"]), CM , d[b , "filt_median"])
  }
  
  #smoothing of raw data
  fs <-
    1 / 30 # camera frame rate is 30 frames/second.  fs=1/framerate
  d$time <- d$Slice / 30 # create a time variable
  
  #center temp values for avoiding filter edge effect
  d$m.center <- d$filt_median - mean(d$filt_median)
  
  library(signal)
  bf <- butter(2, W = 1 / 5, type = "low") # low pass filter.
  # set the W parameter appropriately to get rid of fast responses.
  
  filteredsignal <- filtfilt(bf, x = d$m.center)
  
  #adding filtered column to data and adding the mean of the original measurements
  d$filteredsignal <-  filteredsignal
  d$filt_med <- d$filteredsignal + mean(d$filt_median)
  
  #plot raw and processed data for visual check
  par(mfrow = c(2, 1))
  plot(
    d$time,
    d$filt_med ,
    type = "l",
    lwd = 2,
    main = paste(
      d$`loopy$name`[1],
      min(d$Slice),
      "-",
      max(d$Slice),
      "butterworth"
    )
  )
  lines(d$filt_median ~ d$time, col = "red")
  
  
  #### finding mins and maxs of the breathig curve ######
  
  dyad.dist <- d$filt_med #called this dyad.dist to match function
  
  plot.results <- F
  noise.thresh <- 0.25 #this is the stating max threshold value.
                       #can be adapted according to data
  
  n.times <- length(dyad.dist)
  
  # setting a repeat counter for getting out of endless loops
  int <- 1
  
  repeat {
    #---find first minimum---
    #get first instance of a change in dyadic distance above noise.thresh, and determine whether it is going up or down
    i <- 1
    curr.min <- 1
    found = F
    while (found == F & i < length(dyad.dist)) {
      dist.change <- dyad.dist[i] - dyad.dist[1]
      if (dyad.dist[i] < dyad.dist[curr.min]) {
        curr.min <- i
      }
      if (abs(dist.change) > noise.thresh) {
        found = T
        if (dist.change > 0) {
          up.first <- T
        }
        else{
          up.first <- F
        }
      }
      else{
        i <- i + 1
      }
    }
    
    #if no first minimum found, return NULL
    if (!found) {
      print('no first minimum found')
    }
    
    #find starting point (if it went up first, this is curr.min, otherwise, this is the first minimum)
    if (up.first) {
      first <- curr.min
    } else{
      curr.min <- 1
      found <- F
      while (i < n.times & !found) {
        dist.diff <- dyad.dist[i] - dyad.dist[curr.min]
        if (dist.diff < 0) {
          curr.min <- i
        }
        else{
          if (dist.diff > noise.thresh) {
            found <- T
            first <- curr.min
          }
        }
        i <- i + 1
      }
      if (!found) {
        #if no starting point found, return NULL
        return(NULL)
      }
    }
    
    #----pull out maxes and mins in dyadic distance----
    min.max.min <- data.frame(t1 = NA, t2 = NA, t3 = NA)
    min.max.min$t1[1] <- first
    ref.idx <- first
    ref.val <- dyad.dist[first]
    data.idx <- 1
    going.up <- T
    for (i in first:n.times) {
      curr.idx <- i
      curr.val <- dyad.dist[i]
      if (going.up) {
        #if going up
        if (curr.val >= ref.val) {
          #if the current value is greater than the reference value
          ref.idx <-
            curr.idx #replace the reference value with the current value
          ref.val <- dyad.dist[ref.idx]
        }
        if (abs(curr.val - ref.val) > noise.thresh) {
          #if the difference between current and reference exceeds the noise threshold
          min.max.min$t2[data.idx] <- ref.idx #record the local max
          going.up <- F #switch to going down
          ref.val <- curr.val
          ref.idx <- curr.idx
        }
      }
      else{
        #if going down
        if (curr.val <= ref.val) {
          #if the current value is less than the reference value
          ref.idx <-
            curr.idx #replace the reference value with the current value
          ref.val <- dyad.dist[ref.idx]
        }
        if (abs(curr.val - ref.val) > noise.thresh) {
          #if the difference between current and reference exceeds a noise threshold
          min.max.min$t3[data.idx] <-
            ref.idx #record the local min as the end of the current sequence
          data.idx <- data.idx + 1 #increment the data index
          min.max.min <-
            rbind(min.max.min, c(ref.idx, NA, NA)) #record the local min as the start of the next sequence
          going.up <- T #switch to going up
          ref.val <- curr.val
          ref.idx <- curr.idx
        }
      }
    }
    
    
    #remove the last row if it is incomplete to get full cycles
    min.max.min.comp <- min.max.min[which(!is.na(min.max.min$t3)),]
    
    #calculate breathing rate based on the number of max peaks
    rate <-
      (d[max(min.max.min.comp$t3, na.rm = T) , "time"] - d[min(min.max.min.comp$t1, na.rm = T) , "time"]) /
      (length(which(!is.na(
        min.max.min.comp[, 2]
      ))) - 1)
    
    #print the current peak detection threshold and the estimated breathing rate
    print(noise.thresh)
    print(rate)
    
    # conditions to end the repeat loop.
    if (noise.thresh < 0.04) {
      break
    } #if noise.thresh gets bellow 0.04
    if (int == 51) {
      break
    }           # if loop goes over 50 iterations
    if (rate < 1.2)  {
      noise.thresh <-
        noise.thresh + 0.01
    } #if breathing rate is too high add to detection threshold
    else if (rate > 1.9) {
      noise.thresh <-
        noise.thresh - 0.01
      int <-
        int + 1
    } #if breathing rate is too low, lower detection and add 1 to iterations
    
    else {
      break
    }
  }
  
  #secondary filtering of min peaks
  min_temp <- d[min.max.min$t1, "filt_med"]
  min_temp_1 <- d[min.max.min$t1, "Median"]
  
  f <- mean(min_temp_1)
  outliers <- which(min_temp > f + 0.5)
  ifelse (length(outliers) > 0,
          new_peaks <-
            min.max.min[-which(min_temp > f + 0.5) ,] ,
          new_peaks <- min.max.min)
  
  
  #select max peaks
  makemax <-  new_peaks[, 2]
  
  #select min peaks
  makemin <-  new_peaks[, 1]
  
  
  
  ####find plateau region for each peak####
  
  #pull min peak location
  peaks <- sort(unique(unlist(makemin)))
  
  ########  here some manual peak correction conditions could be added based 
  ########   on visual inspection after first run
  
  #make a vector of all peaks
  allpeaks <- sort(c(makemax, peaks))
  
  
  #make separate vectors for peaks from which to go forward or backward.
  #this is done to prevent errors from peaks on the edges of the segment
  for_peaks <- peaks[peaks <  (length(dyad.dist) - 10)]
  rev_peaks <- peaks[peaks > 10]
  
  #make empty vectors for plateau points
  plato.end <- numeric(0)
  plato.start <- numeric(0)
  
  
  #finding plateau start
  for (j in 1:length (for_peaks)) {
    #set the current minimum peak as a starting point and the next max peak(- 2 frames) as the end point
    
    slopes <- data.frame()
    local_stop <-
      allpeaks[(which(allpeaks == for_peaks[j]) + 1)] - 2
    #if there is no next peak set the end of the segment (- 5 frames) as the end point
    if (length(local_stop) == 0 ||
        is.na(local_stop)) {
      local_stop = nrow(d) - 5
    }
    
    #start walking from start to end point making 5 frame regressions and extracting slope values
    for (i in for_peaks[j]:local_stop)
      
    {
      slopes[i , 1] <-
        lm(d$filt_med[i:(i + 5)] ~ d$Slice[i:(i + 5)])$coefficients[2]
      slopes[i, 2] <- i
    }
    
    
    #set new start at the steepest slope point
    new_start <- which(slopes$V1 == max(slopes$V1, na.rm = T))
    
    #from the new start point until the same local stop  make regressions on a 2 frame segments
    secondary_slopes <- data.frame()
    
    for (i in new_start:local_stop)
    {
      secondary_slopes[i, 1] <-
        lm(d$filt_med[i:(i + 2)] ~ d$Slice[i:(i + 2)])$coefficients[2]
      secondary_slopes[i, 2] <- i
    }
    
    
    #find a point where the slope is 1/3 of the steepest one or closest to zero (whatever comes first)
    plato_start <-
      which(abs(secondary_slopes$V1) == min(abs(secondary_slopes$V1), na.rm = T))
    plato_start_alt <-
      min(which(abs(secondary_slopes$V1) < max(abs(slopes$V1), na.rm = T) / 3))
    start_point <- min(plato_start, plato_start_alt, na.rm = T)
    plato.start <- c(plato.start, start_point)
    
    
  }
  
  # finding plateau end
  #do the same but in the opposite direction to find plateau ends
  for (j in 1:length (rev_peaks)) {
    slopes <- data.frame()
    local_stop <-
      allpeaks[(which(allpeaks == rev_peaks[j]) - 1)] + 2
    if (length(local_stop) == 0 ||
        is.na(local_stop)) {
      local_stop =  5
    }
    for (i in rev_peaks[j]:local_stop)
      
      
    {
      slopes[i , 1] <-
        lm(d$filt_med[i:(i - 5)] ~ d$Slice[i:(i - 5)])$coefficients[2]
      slopes[i, 2] <- i
    }
    
    
    new_start <- which(slopes$V1 == min(slopes$V1, na.rm = T))
    
    
    secondary_slopes <- data.frame()
    
    for (i in new_start:local_stop)
    {
      secondary_slopes[i, 1] <-
        lm(d$filt_med[i:(i - 2)] ~ d$Slice[i:(i - 2)])$coefficients[2]
      secondary_slopes[i, 2] <- i
    }
    
    
    
    plato_end <-
      which(abs(secondary_slopes$V1) == min(abs(secondary_slopes$V1), na.rm = T))
    plato_end_alt <-
      max(which(abs(secondary_slopes$V1) < max(abs(slopes$V1), na.rm = T) / 3))
    end_point <- max(plato_end, plato_end_alt, na.rm = T)
    plato.end <- c(plato.end, end_point)
    
  }
  
  #### another step of manual filtering can be added here ###
  #### observing the peak detection visually and adding corrections if needed##
  
  #plot peaks on the filtered signal
  plot(dyad.dist ~ d$Slice, type = 'l', main = upd_file_lst[k]) #filtered signal
  
  abline (v = d$Slice[peaks], col = "red") #minimum
  abline(v = d$Slice[plato.start], col = "gold") #start points
  abline(v = d$Slice[plato.end], col = "blue")    # end points
  
  #making empty matrices for populating with peak location and types
  t1n <- matrix(1, length(plato.end), 1)
  t3n <- matrix(3, length(plato.start), 1)
  #filling plateau start and end points
  t1 <- cbind(plato.end, t1n)
  t3 <- cbind(plato.start, t3n)
  
  
  # creating separate peaks column with all three transition type peak  locations
  
  plato.peaks <- matrix(NA, nrow(d), 2)
  #popplating column with t1 and t3 peaks
  for (i in 1:nrow(t1))
  {
    for (j in 1:2) {
      plato.peaks[t1[i], j] <- paste0(t1[i, j])
    }
  }
  
  for (i in 1:nrow(t3))
  {
    for (j in 1:2) {
      plato.peaks[t3[i], j] <- paste0(t3[i, j])
    }
  }
  #adding  minimum (t2) peaks  to peaks column
  min.peaks <- peaks
  t2n <- matrix(2, length(min.peaks))
  t2 <- cbind(min.peaks, t2n)
  for (i in 1:length(min.peaks))
  {
    {
      for (j in 1:2) {
        plato.peaks[t2[i], j] <- paste0(t2[i, j])
        
      }
    }
    
    
  }
  
  fpeaks <- as.numeric(na.omit(plato.peaks[, 1]))
  
  
  ##making separate columns for change in intensity, frame distance and slope between peaks
  Intensity <- matrix(NA, nrow(d), 1)
  Distance <- matrix(NA, nrow(d), 1)
  Slope <- matrix(NA, nrow(d), 1)
  
  ##calculating all three peak parameters
  for (i in 1:length(fpeaks))
  {
    Intensity[fpeaks[i], 1] <-
      abs(d[fpeaks[i], "Median"] - d[fpeaks[i + 1], "Median"]) #intensity is calculated from the real data to avoid smoothing artefacts
    Distance[fpeaks[i], 1] <-
      abs(d[fpeaks[i], "time"] - d[fpeaks[i + 1], "time"])
  }
  
  for (i in 1:(length(fpeaks) - 1))
  {
    xs <- d[fpeaks[i]:fpeaks[i + 1], "time"]
    ys <- d[fpeaks[i]:fpeaks[i + 1], "Median"]
    
    
    Slope[fpeaks[i], 1] <- lm(ys ~ xs)$coefficients[2]
  }
  
  #adding new columns to data
  d <- cbind(d, plato.peaks)
  colnames(d)[colnames(d) == 1] <- "peak"
  colnames(d)[colnames(d) == 2] <- "phase"
  d <- cbind(d, Intensity , Distance, Slope)
  
  
  #making new columns to fill later
  addcolumns <- matrix(NA, nrow = nrow(d), ncol = 3)
  colnames(addcolumns) <- c("type", "NF", "Call.duration")
  d <- cbind(d, addcolumns)
  
  #clearing previous breaths, NF naming and call count (can be removed if input files are raw)
  d$NF = ""
  d$type = ""
  d$Call.duration = ""
  
  #make column of peak index (idx)
  ll <- length(fpeaks)
  
  #adding the needed factor levels to breaths type column : c = call, ac = after call, bc = before call, n = no call
  levels(d$type) <- c("c", "ac" , "bc" , "n" , "")
  
  #adding breath_index (idx) column
  d$breathidx <- NA
  #making phase column numeric
  d$phase <- as.numeric(d$phase)
  d$Calls <- as.numeric(d$Calls)
  d$peak <- as.numeric(as.character(d$peak))
  #setting the breaths counter
  r <- 1
  
  # setting the first peak as breath #1
  d[fpeaks[1], "breathidx"] <- r
  
  #counting the breaths through the file. As the phase resets new count is added
  for (z in 2:(ll)) {
    if (d[fpeaks[z], "phase"] > d[fpeaks[z - 1], "phase"]) {
      d[fpeaks[z], "breathidx"] <- r
    } else {
      r <- r + 1
      d[fpeaks[z], "breathidx"] <- r
    }
    
  }
  
  #adding 0s instead of NA to Calls column. Some later step fails without it
  d$Calls[is.na(d$Calls)] = 0
  
  #detecting and marking phases with calls in them
  for (i in 1:(ll - 1)) {
    x <-  any(d[fpeaks[i]:fpeaks[i + 1], "Calls"] == 1, na.rm = F)
    if (x == T)
    {
      d[fpeaks[i], "type"] <- "c"
      
    }
  }
  
  #detecting phases with non focal calls in them
  for (j in 1:(ll - 1)) {
    y <-  any(d[fpeaks[j]:fpeaks[j + 1], "Calls"] == 1 / 2, na.rm = F)
    if (y == T)
    {
      d[fpeaks[j] , "NF"] <- "y"
      d[fpeaks[j + 1] , "NF"] <- "y"
      
    }
  }
  
  #filling the rest of NF peaks as "n"
  for (peaknum in fpeaks) {
    if (d[peaknum , "NF"] != "y") {
      d$NF[peaknum] = "n"
    }
    
  }
  IDX <- 0
  
  #finding and naming all peaks of "call" breaths as c
  for (peaknum in fpeaks) {
    if (d[peaknum, "type"] == "c") {
      IDX <- d$breathidx[peaknum]
      d[which(d$breathidx == IDX), "type"] = "c"
      
      #counting call duration in frames
      #making a table of peak index and breath counter of breaths with calls
      call.breaths <-
        (d[which(d$type == "c"), c("peak", "breathidx")])
      
      #summing up call duration in frames for each breath with calls
      for (breath in IDX) {
        breath.range <-
          range(call.breaths[which(call.breaths$breathidx == breath), 1])
        
        #removing NonFocal calls from the total call duration
        d2 = d
        d2[which(d2$Calls == 0.5), "Calls"] = 0
        d[which(d$breathidx == breath), "Call.duration"] = sum(d2[breath.range[1]:breath.range[2], "Calls"])
      }
    }
  }
  
  
  if (IDX != 0) {
    #making a table of peak index and breath counter of breaths with calls
    call.breaths <-
      (d[which(d$type == "c"), c("peak", "breathidx")])
    
    
    #finding and naming all peaks of after-call breaths - "ac"
    for (peak1 in fpeaks) {
      if (d$type[peak1] == "c") {
        IDXAC <- d$breathidx[peak1] + 1
        d[which(d$breathidx == IDXAC), "type"] = "ac"
      }
    }
    #finding and naming all peaks of before-call breaths = "bc"
    for (peak2 in fpeaks) {
      if (d$type[peak2] == "c") {
        IDXBC <- d$breathidx[peak2] - 1
        d[which(d$breathidx == IDXBC), "type"] = "bc"
      }
      
    }
    
  }
  #filling the rest of the unassigned peaks with "n"
  for (peaknum in fpeaks) {
    if (d$type[peaknum] == "") {
      d$type[peaknum] = "n"
    }
    #selecting rows with actual peak values
    filt <- d[d$type != "",]
    
    #Calculating mean breathing rate for benchmark of peak detection
    BRate_file <-
      data.frame((filt[max(which(filt$phase == 3)) , "time"] -   filt[min(which(filt$phase == 3)) , "time"]) /
                   (length(which(filt$phase == 3)) - 1), filt$seqID[1])
  }
  

  #filling up data summary file
  summ <- rbind(summ, filt)
  raw_summ <- rbind(raw_summ, d)
  #filling us breathing rates
  Breathrate_tot <- rbind(Breathrate_tot, BRate_file)
  
}

colnames(Breathrate_tot) <- c("rate", "file")

#Getting column names for the summary files
columns <- colnames(filt)
colnames(summ) <- columns


print(mean(Breathrate_tot[, 1]))
Breathrate_tot[, 1]
#write files
write.csv(summ, "/cloud/project/data_outputs/peaksummary4stats.csv"  )
write.csv(raw_summ, "/cloud/project/data_outputs/full_summary4fig.csv"  )